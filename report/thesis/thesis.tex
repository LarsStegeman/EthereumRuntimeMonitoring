\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{url}
\usepackage{listings}
\usepackage{enumitem}

%% Solidity highlighting for listings
\input{solidity-highlighting.tex}
\lstset{escapeinside={<@}{@>}}


\title{Runtime Verification of Smart Contracts \\
\large On the Ethereum network \\}

\author{Lars Stegeman [s1346466]\\ l.stegeman@student.utwente.nl}

\begin{document}

\maketitle

\tableofcontents



\section{Abstract}

\section{Introduction}

\section{Solidity}
Section explains basics of solidity in order to understand the rest of the paper. Same section as in ResearchTopics

\section{Tool Overview}
\begin{itemize}
  \item Tool works in two phases validation and generation.
  \item Validation typechecks and checks if annotations are well formed according to grammar.
  \item Generation generates original solidity code with extra added code to check annotations at runtime.
  \item Approach uses a Solidity grammar that can be updated easily for future updates.
  \item Output of validation phase can be used for other verification tools (result is a parse tree).
  \item Annotations can be defined as invariants and pre or post conditions for functions.
  \item Annotations use JML like syntax.
  \item Tool can be used both during development (as extra test cases) or on the actual live blockchain (this probably costs a lot of extra gas = ether).
\end{itemize}
\begin{center}
  \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{resources/ToolOverview.png}
\end{center}
In the picture the complete overview of the tool can be seen. Within the dashed square the implemented parts are visible. The arrows indicate the flow of the contract code throughout the program. \\
First contract code has to be annotated according to a specified grammar. Section \ref{sec:annotationlanguage} explains the grammar in more detail and gives some example annotations. The tool ANTLR is used to generate code for the lexer and parser. The result of this step is a parse tree which can be used for later stages. \\
The next step is type checking the annotations. This uses the parse tree to examine the annotations and check if they are valid. The type checking is done bottom up and works in two phases. The first phase collects all the relevant variables. This includes state variables and function definitions (function name, arguments and return values). The next phase uses this information to do the actual type checking of the annotations. This is explained in more detail in Section \ref{sec:typechecker}. \\
The result of the type checker phase are type-checked annotations. In practice these are parse tree objects in which the types correspond to the operators used and the identifiers that are used are also defined in the contract. This is used as input for the generation phase. The generation phase will operate on the information that is created during the type checker phase. For each annotation it will generate the code that is needed to check it during runtime. This happens in a single passage of the complete parse tree. Details on this phase can be found in Section \ref{sec:generation}. \\
Using the annotation grammar all specifications can be expressed. But not all specifications can be translated to code that can be checked at runtime. This means that some annotations will not be translated to runtime monitored contract code. This is the case because of limitations within the Solidity language. For example the mapping type is not iterable and the keys are not known. This means that mappings have to be replaced with other constructions. In the current state of the tool only basic mappings can be replaced with iterable constructions. \\
The output of the type checker phase can also be used for other static analysis tools. The benefit of using the tool to validate the annotations is that the result is a type checked parse tree that can be parsed and traversed in various ways to be useful for static verification methods. 

\section{Annotation Language}
\label{sec:annotationlanguage}
The first step towards implementing the tool is to define an annotation syntax, and formally write this down using a grammar. The parser generator that is used is called ANTLR. Using the grammar definition the lexer and parser will be automatically generated. The output of this phase is a parse tree that can be used in later stages of the tool.

\subsection{Grammar definition}
There already exists a grammar for the complete Solidity language. This grammar is written down using the language that is used by ANTLR tool. ANTLR has the capabilities to extend certain grammars. This is done by inheritance over the original grammar. This principle is explained in detail here (find ref). We will use this principle to extend the grammar of Solidity to recognize the special annotations that will later be used in the tool. \\
The annotations have certain requirements that can be summarized the following way. Later each requirement is discussed in detail.
\begin{itemize}
    \item Annotations can be specified at the top level of the contract.
    \item Annotations should be able to reference all variables used in the contract.
    \item Basic math operations can be used within annotations.
    \item Annotations can not have side effects.
    \item The type should be boolean at the highest level (that way they can be verified).
    \item There are two types of annotations invariants and pre- or postconditions to a function.
\end{itemize}

The annotation syntax is heavily inspired from the JML annotation syntax. But has a lot less built in keywords since the setting is easier and the tool is less complex. The original grammar is extended in such a way that annotations can only be defined on the top level. The relevant parts of the original Solidity grammar can be seen in the snippet below. This does not include the full grammar specification but only the parts that are relevant for the annotation syntax.

\begin{lstlisting}[basicstyle=\ttfamily]
grammar Solidity;

sourceUnit
  : (pragmaDirective | importDirective | contractDefinition)* EOF ;

contractDefinition
  : ( 'contract' | 'interface' | 'library' ) identifier
    ( 'is' inheritanceSpecifier (',' inheritanceSpecifier )* )?
    '{' contractPart* '}' ;

contractPart
    : stateVariableDeclaration
    | usingForDeclaration
    | structDefinition
    | constructorDefinition
    | modifierDefinition
    | functionDefinition
    | eventDefinition
    | enumDefinition ;
\end{lstlisting}
In the original grammar the definition of \texttt{contractPart} is what defines the declaration of variables and the definitions for structs and functions. This is where the extra annotations have to be added to the grammar. The snippet below shows the basic definition of an annotation. This is not the complete grammar some of the tokens are omitted from this snippet, since they are not required to understand the grammar definition.
\begin{lstlisting}[basicstyle=\ttfamily]
grammar SolidityAnnotated;
import Solidity;

contractPart
  : stateVariableDeclaration
  | usingForDeclaration
  | structDefinition
  | constructorDefinition
  | modifierDefinition
  | functionDefinition
  | eventDefinition
  | enumDefinition 
  <@\textcolor{red}{  | annotationDefinition ;}@>

annotationDefinition
  : AnnotationStart AnnotationKind annotationExpression ;

annotationExpression
  : '(' annotationExpression ')'
  | annotationExpression compareOp annotationExpression
  | annotationExpression booleanOp annotationExpression
  | annotationExpression integerOpBoolean annotationExpression
  | annotationExpression integerOpInteger annotationExpression
  | '!'annotationExpression
  | ('\\forall' | '\\exists') '(' identifier elementaryTypeName ':' annotationExpression? ':' annotationExpression')'
  | primaryAnnotationExpression ;

primaryAnnotationExpression
  : primaryExpression 
  | primaryAnnotationExpression '.' identifier
  | primaryAnnotationExpression '[' primaryExpression ']'
  | '\\old' '(' primaryAnnotationExpression ')' ;

AnnotationStart
  : '//@' ;

AnnotationKind
  : 'inv'| 'pre'| 'post' ;

LINE_COMMENT 
  : '//' ~[@] ~[\r\n]* -> channel(HIDDEN) ;
\end{lstlisting}
An AnnotationDefinition is composed of multiple components. It has a \texttt{AnnotationStart}, \texttt{AnnotationKind} and \texttt{annotationExpression} component. The \texttt{AnnotationStart} token is used to signal that an annotation definition is coming next. This is defined as '//@' making it a line comment to other solidity compilers. This makes annotated solidity code still compilable by normal compilers. For the grammar to accept this notation the \texttt{LINE\_COMMENT} token has to be adjusted to not accept '@' as a second character. Otherwise all annotation comments would be recognized as a \texttt{LINE\_COMMENT} making it unusable. \\
There are two types of annotations they are defined by the token \texttt{AnnotationKind}. They can either be a invariant or a pre- or post-condition of a function. \\
Each annotation has an expression which has to be evaluated called \texttt{annotationExpression}. The expression parser rules are separated between \texttt{annotationExpression} and \texttt{primaryAnnotationExpression}. This is needed to keep the hierarchy in parsing and prevent using primary definitions within complex expressions. For example using the keyword '\textbackslash old' before parenthesis.\\
The annotation expressions use a different parser rules than the expression rules that are used within the original Solidity grammar. The \texttt{annotationExpression} does not allow syntax like \texttt{expression + '++'} and to distinguish these a new parser rule was introduced for annotations only. \texttt{primaryExpression} and \texttt{identifier} are parser rules that are defined in the original Solidity grammar. The annotation expressions make use of these rules so that they do not have to be defined again.

\subsection{Examples}
In this section a couple of annotation examples will be given for example contracts. First a contract snippet is shown and later the meaning of this annotation is explained.
\lstinputlisting[language=Solidity, linerange={4-6}]{examples/BasicAnnotations.sol}
Defines an invariant that will be checked at the start and end of every function. \texttt{nr1} and \texttt{nr2} are global contract variables. \texttt{nr1} should always be bigger then \texttt{nr2}.
\lstinputlisting[language=Solidity, linerange={9-13}]{examples/BasicAnnotations.sol}
Defines a post condition on the function \texttt{doSomething()}. Checks if the owner is not changed during execution of the function.
\lstinputlisting[language=Solidity, linerange={14-16}]{examples/BasicAnnotations.sol}
Defines an invariant that will check if all elements in array \texttt{a} are positive.
\lstinputlisting[language=Solidity, linerange={19-23}]{examples/BasicAnnotations.sol}
Postcondition for the function \texttt{changeSomething()}. If the sender of this transaction is equal to the owner (\texttt{msg.sender}), variable \texttt{b} must be different from the start of the function. 

\section{Type Checker}
\label{sec:typechecker}
\subsection{Design}
Annotations have to be validated on certain aspects for them to be correct and usable. These aspects have to be verified first for the annotations to be useful in the next generation phase. The parser ensures annotations are syntactically correct however there are more properties that have to be checked. The typecheck phase will consist of two phases that walk the complete parse tree. The first walk will collect all the variables and defined structures and store these in an information object. The second walk will type check each annotation individually. During this type checking the type of each identifier is looked up using the collected information from the first walk. 
\subsection{Implementation}


\section{Generation}
\label{sec:generation}
\begin{itemize}
    \item Explain generation of functions for annotations. Each annotation will be transformed to a function, the function takes in arguments that are also generated automatically.
    \item Explain how functions are calling the code for checking annotations. Original Function will be transformed to a private function and renamed to 'functionName"+ \_body. New function calls this function with the extra annotations.
    \item Implementation of generation is using a TokenStreamRewriter (with whitespace) and an abstract parse tree (only tokens that are in grammar). Tokens in both structures know the position, this way the original solidity code can be printed and extra code can be added through traversing the parse tree.
\end{itemize}
\subsection{Mapping}

\section{Tool Usage}


\section{Case study}
\begin{itemize}
  \item Take contract that has vulnerability and add annotations
  \item Show parts of generated code that will throw an event.
  \item Show difference in gas usage?
  \item Show how forall annotations are handled (example contract of minimal token).
\end{itemize}
In this section we present two case studies of smart contracts. These smart contracts will be annotated and the tool will generate the contract code with extra checks added to the code. The first example is a minimal token implementation. The second example is a contract with a vulnerability which we will show can be detected with the correct annotations.

\subsection{SimpleToken}
In this example we will use the contract SimpleToken. The contract code can be found on the Ethereum Foundation website \footnote{\url{https://www.ethereum.org/token}}. 
It models a minimum viable token. To keep the state of the contract a \texttt{mapping} is used that maps \texttt{address} to \texttt{uint}. This mapping is kept in the contracts' internal storage and is stored on the blockchain. It indicates which amount each address holds of this token and changes each time the \texttt{transfer} function is called. The \texttt{transfer} function requires two parameters an address (\texttt{\_to})  and an uint(\texttt{\_value}) which specifies the amount to be sent. The from address is determined from the global variable \texttt{msg} which is present in each transaction. The require statements in the transfer function will check if the sender has enough balance to sent the amount specified in \texttt{\_value}, and test for overflows in the balance of the receiver. If one of the two fails an exception will be thrown and the changes this transaction made will be reverted.\\
When the contract is created the constructor will be called. In this constructor the initialSupply is given as a parameter. All the initial supply is given to the contract creator (\texttt{msg.sender}). The totalSupply value is assigned and cannot be changed after initialization.\\
Note that this contract is not ERC20 compliant. ERC20 is the interface that most tokens use to implement the desired functionality. This interface is defined in order for all wallets and exchanges to be able to handle different tokens \footnote{\url{https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md}}. The main difference is that this contract does not have an \texttt{approve} mapping which lets users approve a certain transfer of tokens. Also this SimpleToken does not allow \texttt{minting} or \texttt{burning} of tokens, in other words the total supply is fixed. Below we can see the Solidity source code of the contract SimpleToken.

\lstinputlisting[language=Solidity, tabsize = 2]{examples/SimpleToken.sol}

\subsubsection{Annotation}
The above section describes the implementation of the token contract. However there is also a specification given in words as to what the contract should do. A few properties of this specification can be declared explicitly using pre and postconditions or invariants. These properties are important to the functionality of the contract. 
The first property is that when a transfer function is executed the balance of the \texttt{\_to} address is incremented with the \texttt{\_value}. And the balance of the sender is decreased with the same value. The rest of the balances remains the same. This property should be checked after the execution of the \texttt{transfer} function. Using the correct syntax the annotation will look:
\begin{lstlisting}[basicstyle=\ttfamily, breaklines=true ]
//@ post 
 balanceOf[_to] == (\old(balanceOf[_to]) + _value) 
 && balanceOf[msg.sender] == (\old(balanceOf[msg.sender]) - _value) 
 && \forall(x in balanceOf: (x != _to && x != msg.sender) -> balanceOf[x] == \old(balanceOf[x])) 
 && msg.sender != _to 
\end{lstlisting}
Going over it line by line:
\begin{enumerate}
  \item Indicate that this is an annotation and not a comment. And this is of type post condition
  \item Balance of \texttt{\_to} gets incremented by \texttt{\_value}
  \item Balance of \texttt{msg.sender} gets decremented by \texttt{\_value}
  \item Rest of the balances does not change.
  \item This is makes the annotation also valid for the special case where \texttt{\_to} is equal to \texttt{msg.sender}.
\end{enumerate}

\subsubsection{Generated Code}
When the tool gets executed with the above contract as input including the annotation, the tool will parse the annotation and output generated solidity code with extra checks. 
The complete generated code can be seen below.
\lstinputlisting[language=Solidity, tabsize = 2, literate={\ \ }{{\ }}1]{examples/SimpleToken_generated.sol}

Note that the functionality of this contract is exactly the same as the previous code but with extra checks. This means that this approach is only feasible for development purposes. Since the gas cost of executing the previous contract is much lower then that of the runtime monitored contract. Also the more addresses that get added to the iterable map the more gas the transaction will consume.


\subsection{Vulnerable Contract}
The next example is a simple contract with a vulnerability. The vulnerability will not be easily visible when reading the contract, but with extra annotations added this is visible. This contract is not actually in use but is based on a CryptoRoulette contract \footnote{https://github.com/misterch0c/Solidlity-Vulnerable/blob/master/honeypots/CryptoRoulette.sol}. Most of the contract code is omitted for this example. The idea is that the contract keeps a list of messages, for each message the sender and the message are saved. Only the address \texttt{admin} has extra privileges to possibly delete messages or delete the contract (these functions are not in the snippet).
\lstinputlisting[language=Solidity, tabsize = 2, literate={\ \ }{{\ }}1]{examples/VulnerableContract.sol}

\subsubsection{Annotation}
The annotation that is added to the function \texttt{logMessage} checks the basic behaviour of the function. The address \texttt{admin} should not be changed, and the number of messages should be increased by one. This should be checked after the function is executed.
\begin{lstlisting}[basicstyle=\ttfamily, breaklines=true ]
//@ post admin == \old(admin) && (nrOfMessages == (\old(nrOfMessages) + 1))
\end{lstlisting}
\subsubsection{Generated Code}
The code that is generated stores the original variables in memory before calling the function body. After the function is executed the old variables will be compared to the current state variables. Every call to the function \texttt{logMessage} will report an error since each time the state variables \texttt{admin} and \texttt{nrOfMessages} are changed. These are changed because the struct \texttt{message} within the function body defaults to \texttt{storage}. 
\lstinputlisting[language=Solidity, tabsize = 2, literate={\ \ }{{\ }}1]{examples/VulnerableContract_generated.sol}

\section{Future work}
\begin{itemize}
  \item The tool cannot handle contract inheritance.
  \item The tool does not have a mechanism for exposing the parse tree for other programs after validation.
\end{itemize}

\section{Related Work}
\begin{itemize}
  \item ContractLarva: runtime monitoring based on defined states and transitions.
  \item 
\end{itemize}

\end{document}