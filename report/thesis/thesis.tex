\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{url}
\usepackage{listings}
\usepackage{enumitem}

%% Solidity highlighting for listings
\input{solidity-highlighting.tex}
\lstset{escapeinside={<@}{@>}}

\title{Runtime Verification of Smart Contracts \\
\large On the Ethereum network \\}

\author{Lars Stegeman [s1346466]\\ l.stegeman@student.utwente.nl}

\begin{document}

\maketitle

\tableofcontents



\section{Abstract}

\section{Introduction}

\section{Solidity}
Section explains basics of solidity in order to understand the rest of the paper. Same section as in ResearchTopics

\section{Tool Overview}
% \begin{itemize}
%   \item Tool works in two phases validation and generation.
%   \item Validation typechecks and checks if annotations are well formed according to grammar.
%   \item Generation generates original solidity code with extra added code to check annotations at runtime.
%   \item Approach uses a Solidity grammar that can be updated easily for future updates.
%   \item Output of validation phase can be used for other verification tools (result is a parse tree).
%   \item Annotations can be defined as invariants and pre or post conditions for functions.
%   \item Annotations use JML like syntax.
%   \item Tool can be used both during development (as extra test cases) or on the actual live blockchain (this probably costs a lot of extra gas = ether).
% \end{itemize}
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{resources/ToolOverview.eps} 
In the picture the complete overview of the tool can be seen. Within the dashed square the implemented parts are visible. The arrows indicate the flow of the contract code throughout the program. \par
First contract code has to be annotated according to a specified grammar. Section \ref{sec:annotationlanguage} explains the grammar in more detail and gives some example annotations. The tool ANTLR \cite{parr2013definitive} is used to generate code for the lexer and parser. The grammar has to be expressed in the language that is recognized by the ANTLR tool. The automatically generated parser is used to parse Solidity contract code and annotations into a parse tree. The parse tree makes it able to walk the complete contract code and do analysis on specific parts of the contract. This parse tree is used in later stages of the tool. \par
The next step is type checking the annotations. This uses the parse tree to examine the annotations and check if they are valid. The type checking is done bottom up and works in two phases. The first phase collects all the relevant variables. This includes state variables and function definitions (function name, arguments and return values). The next phase uses this information to do the actual type checking of the annotations. This is explained in more detail in Section \ref{sec:typechecker}. \par
The result of the type checker phase are type-checked annotations. In practice these are parse tree objects in which the types correspond to the operators used and the identifiers that are used are also defined in the contract. This is used as input for the generation phase. The generation phase will operate on the information that is created during the type checker phase. For each annotation it will generate the code that is needed to check it during runtime. This happens in a single pass of the complete parse tree. Details on this phase can be found in Section \ref{sec:generation}. \par
Using the annotation grammar all specifications can be expressed. But not all specifications can be translated to code that can be checked at runtime. This means that some annotations will not be translated to runtime monitored contract code. This is the case because of limitations within the Solidity language. For example the mapping type is not iterable and the keys are not known. This means that mappings have to be replaced with other constructions. In the current state of the tool only basic mappings can be replaced with iterable constructions. \par
The output of the type checker phase can also be used for static analysis tools. The benefit of using the tool to validate the annotations is that the result is a type checked parse tree that can be parsed and traversed in various ways to be useful for static verification methods. 

\section{Annotation Language}
\label{sec:annotationlanguage}
The first step towards implementing the tool is to define an annotation syntax, and formally write this down using a grammar. The parser generator that is used is called ANTLR \cite{parr2013definitive}. Using the grammar definition the lexer and parser will be automatically generated. The output of this phase is a parse tree that can be used in later stages of the tool.

\subsection{Grammar definition}
There already exists a grammar for the complete Solidity language \cite{antlroriginalgrammar}. This grammar is expressed in the language that is used by ANTLR tool. ANTLR has the capabilities to extend certain grammars. This is done by inheritance over the original grammar. This principle is explained in detail here \footnote{\url{https://github.com/antlr/antlr4/blob/master/doc/grammars.md}}. It functions much like object oriented inheritance. The main grammar inherits all rules, token specifications and named actions from the imported grammar. Rules in the main grammar override rules in the imported grammar. We will use this principle to extend the grammar of Solidity to recognize the special annotations that will later be used in the tool. In this case the imported grammar is the original Solidity grammar. The 'new' main grammar is defined further below and is called SolidityAnnotated. The advantage of this approach is that changes to the original Solidity grammar can easily be updated in the tool. This only holds for small changes to the language, if grammar rules that the tool makes use of the SolidityAnnotated grammar also has to be updated.\par
The annotations have certain requirements that can be summarized the following way. Later each requirement is discussed in detail.
\begin{itemize}
    \item Annotations can be specified at the top level of the contract.
    \item Annotations should be able to reference all variables used in the contract.
    \item Basic math operations can be used within annotations.
    \item Annotations can not have side effects.
    \item The type should be boolean at the highest level (that way they can be verified).
    \item There are two types of annotations: invariants and pre- or postconditions to a function.
\end{itemize}

The annotation syntax is heavily inspired from the JML annotation syntax \cite{leavens2008jml}. But has a lot less built in keywords since the setting is easier and the tool is less complex. \par
The original Solidity grammar is extended in such a way that annotations can only be defined on the top level. The relevant parts of the original Solidity grammar can be seen in the snippet below. This does not include the full grammar specification but only the parts that are relevant for the annotation syntax.

\begin{lstlisting}[basicstyle=\ttfamily]
grammar Solidity;

sourceUnit
  : (pragmaDirective | importDirective | contractDefinition)* EOF ;

contractDefinition
  : ( 'contract' | 'interface' | 'library' ) identifier
    ( 'is' inheritanceSpecifier (',' inheritanceSpecifier )* )?
    '{' contractPart* '}' ;

contractPart
    : stateVariableDeclaration
    | usingForDeclaration
    | structDefinition
    | constructorDefinition
    | modifierDefinition
    | functionDefinition
    | eventDefinition
    | enumDefinition ;
\end{lstlisting}
In the original grammar the definition of \texttt{contractPart} is what defines the declaration of variables and the definitions for structs and functions. This is where the extra annotations have to be added to the grammar. The snippet below shows the basic definition of an annotation. This is not the complete grammar: some of the tokens are omitted from this snippet, since they are not required to understand the grammar definition.
\begin{lstlisting}[basicstyle=\ttfamily, breaklines=true]
grammar SolidityAnnotated;
import Solidity;

@header {package generated;}

//Added annotationDefinition. This enables annotations to be on the top level only.
contractPart
  : stateVariableDeclaration
  | usingForDeclaration
  | structDefinition
  | constructorDefinition
  | modifierDefinition
  | functionDefinition
  | eventDefinition
  | enumDefinition 
  <@\textcolor{red}{  | annotationDefinition ;}@>

annotationDefinition
  : AnnotationStart AnnotationKind annotationExpression;

// Same as the expression rule except it does not include assignments, only comparisons
annotationExpression
  : '(' annotationExpression ')'
  | '!'annotationExpression
  | ('\\forall' | '\\exists') '(' identifier 'in' identifier ':' annotationExpression')'
  | annotationExpression integerOpInteger annotationExpression
  | annotationExpression integerOpBoolean annotationExpression
  | annotationExpression compareOp annotationExpression
  | annotationExpression booleanOp annotationExpression
  | primaryAnnotationExpression;

primaryAnnotationExpression
  <@\textcolor{red}{: primaryExpression}@> 
  | primaryAnnotationExpression '.' <@\textcolor{red}{identifier}@> 
  | primaryAnnotationExpression '[' primaryAnnotationExpression ']'
  | '\\old' '(' primaryAnnotationExpression ')';

//Annotation Tokens
AnnotationStart
  : '//@';

AnnotationKind
  : 'inv'| 'pre'| 'post';

// Added '->' for then.
booleanOp
  : '&&' | '||' | '->';

compareOp
  : '==' | '!=';

integerOpBoolean
  : ('>'|'>='|'<'|'<=');

integerOpInteger
  : '+' | '-';

// Remove '@' from first position of LINE_COMMENT token. 
LINE_COMMENT 
  : '//' ~[@] ~[\r\n]* -> channel(HIDDEN);
// Send whitespace to channel hidden.
WS
  : [ \t\r\n\u000C]+ -> channel(HIDDEN);
\end{lstlisting}
An AnnotationDefinition is composed of multiple components. It has a \texttt{AnnotationStart}, \texttt{AnnotationKind} and \texttt{annotationExpression} component. The \texttt{AnnotationStart} token is used to signal that an annotation definition is coming next. This is defined as '//@' making it a line comment to other solidity compilers. This makes annotated solidity code still compilable by normal Solidity compilers. For the grammar to accept this notation the \texttt{LINE\_COMMENT} token has to be adjusted to not accept '@' as a second character. Otherwise all annotation comments would be recognized as a \texttt{LINE\_COMMENT} making it unusable. \par
There are three types of annotations that are defined by the token \texttt{AnnotationKind}. They can either be an invariant or a pre- or post-condition of a function. Invariants are defined per contract, and should hold at any point during the execution of the contract. Pre- or post-conditions are defined for a specific method. They are checked before and after execution of the method. Each annotation has an expression which has to be evaluated called \texttt{annotationExpression}. The expression parser rules are separated between \texttt{annotationExpression} and \texttt{primaryAnnotationExpression}. This is needed to keep the hierarchy in parsing and prevent using complex expressions within primary definitions. For example using the keyword '\textbackslash old' before parenthesis. The annotation expressions use a different parser rules than the expression rules that are used within the original Solidity grammar. The \texttt{annotationExpression} does not allow syntax like \texttt{expression + '++'} and to distinguish these a new parser rule was introduced for annotations only. \par
The order in which the different subrules are defined in the \texttt{annotationExpression} is imported. The order indicates the priority which the subrules are given. This means that parenthesis bind stronger then any other rule, this is followed by \texttt{!} and so on. The \texttt{annotationExpression} construction contains all the logical comparators that can be used within annotations. In general they are of the form \texttt{expression - <operand> - expression}. The expression are defined recursively thus making it able to form longer expressions with multiple operands. The parser rules in \texttt{primaryAnnotationExpression} are used as leaves in the expression. \texttt{primaryExpression} reverts to different kinds of literals that are used in Solidity. The other rules deal with complex types of Solidity and the possibility to reference an old variable.  
\texttt{primaryExpression} and \texttt{identifier} are parser rules that are defined in the original Solidity grammar. The annotation expressions make use of these rules so that they do not have to be defined again. These rules do not include assignments and are without side effects. The \texttt{primaryExpression} parser rule includes all the literals that can be used within Solidity. The parser rule \texttt{identifier} is used for all kinds of identifiers such as function identifiers and variable identifiers. Function calls are not allowed within annotations, for more details see Section \ref{sec:limitations}.

\subsection{Examples}
In this section a couple of annotation examples will be given for example contracts. First a contract snippet is shown and later the meaning of this annotation is explained.
\lstinputlisting[language=Solidity, linerange={4-6}]{examples/BasicAnnotations.sol}
Defines an invariant that will be checked at the start and end of every function. \texttt{nr1} and \texttt{nr2} are global contract variables. \texttt{nr1} should always be bigger than \texttt{nr2}.
\lstinputlisting[language=Solidity, linerange={9-13}]{examples/BasicAnnotations.sol}
Defines a post condition on the function \texttt{doSomething()}. Checks if the owner is not changed during execution of the function.
\lstinputlisting[language=Solidity, linerange={14-16}]{examples/BasicAnnotations.sol}
Defines an invariant that will check if all elements in array \texttt{a} are positive.
\lstinputlisting[language=Solidity, linerange={19-23}]{examples/BasicAnnotations.sol}
Postcondition for the function \texttt{changeSomething()}. If the sender of this transaction is equal to the owner (\texttt{msg.sender}), variable \texttt{b} must be different from the start of the function. 
\lstinputlisting[language=Solidity, linerange={25-27}]{examples/BasicAnnotations.sol}
Example of a mapping that maps \texttt{address} to \texttt{uint256}. The invariant checks the key \texttt{adr} in the map and checks if it is equal to 5. \hfill\\
A few example of expressions that do not parse correctly:
\lstinputlisting[language=Solidity, linerange={4-9}]{examples/ParseError.sol}
Functions are not recognized in annotations. This is because some functions could have side effects. This can be checked in typechecker but is not implemented yet.
\lstinputlisting[language=Solidity, linerange={11-14}]{examples/ParseError.sol}
The construction \texttt{\textbackslash old()} can only reference primary expression and not complex expressions.

\section{Type Checker}
\label{sec:typechecker}
\subsection{Design}
Annotations have to be validated on certain aspects for them to be meaningful. These aspects have to be verified first for the annotations to be useful in the next generation phase. The parser ensures annotations are syntactically correct however there are more properties that have to be checked. The typecheck phase will consist of two passes that walk the complete parse tree. The first walk will collect all the variables and defined structures and store these in an information object. The second walk will type check each annotation individually. During this type checking the type of each identifier is looked up using the collected information from the first walk. 
\subsection{Implementation}
During the first phase all the variables, structs and function definitions are stored in an object. This object is later used by the second phase to retrieve information.
\begin{lstlisting}[breaklines=true, language=Java ]
public class ValidationInformation {
  ArrayList<SolidityVariable> identifiers;
  ArrayList<SolidityFunction> functions;
  ArrayList<SolidityStruct> structs;

  ...
}
\end{lstlisting}
\begin{itemize}
  \item SolidityVariable is an object which has a name (the identifier) and a type. These model state variables in a contract.
  \item SolidityFunction is an object which represent a function and stores the name and arguments. The arguments are of type SolidityVariable.
  \item SoldityStruct is an object that represent struct definitions in a solidity contract. It stores the name and elements. Elements are again of type SolidityVariable.
\end{itemize}
Solidity has many types and to make generation and typechecking easier the types are reduced to 8 base types (\texttt{uint256, uint128} etc are all regarded as \texttt{INTEGER}). These are all represented in the enumeration \texttt{SolidityType}, and all the internal representation of contract code make use of it. The internal representations must deal with nested constructions. For example consider the following solidity code:
\begin{lstlisting}[breaklines=true, language=Solidity ]
struct A{
    B b;
}
struct B {
    uint256 nr;
}
A var1;
\end{lstlisting}
For this Solidity code the typechecker would create two \texttt{SolidityStruct} objects, \texttt{A} and \texttt{B}. Struct \texttt{B} contains a variable texttt{nr} of type \texttt{INTEGER}, struct \texttt{A} contains a variable \texttt{b} of type \texttt{STRUCT} with reference to \texttt{B}. There also is a global variable \texttt{var1} with type \texttt{STRUCT} with reference to \texttt{A}. \par
The next phase will only parse the annotation part of the contract code, this means that no original solidity contract code will be reached. This is where the actual typechecking happens. It works bottom up, getting the type of each identifier and verifies the types of each step. The top level of each annotation should result in the type \texttt{BOOLEAN}. An extra type \texttt{UNDEFINED} was added to the SolidityType object to deal with cases where the identifier was not found and to produce a result without crashing the program. For the rest of the parse rules/operators the following type system is used:
\begin{itemize}
  \item Base case: expression is a \texttt{primaryAnnotationExpression}. This could mean a identifier where the type is found through the \texttt{SolidityVariable} or a literal of some type. The type can just be passed on to the higher level.
  \item '!' \texttt{expression}: Type checker verifies the nested expression and validates this results in \texttt{BOOLEAN}. Result of this step is always \texttt{BOOLEAN}.
  \item \textbackslash forall | exists( identifier  in identifier: expression): There are multiple things that have to be verified. First the second \texttt{identifier} should be of type \texttt{MAPPING} or \texttt{ARRAY}. Secondly the nested expression is typechecked, this is within a special scope since expressions can make use of the first identifier. This expression should result in \texttt{BOOLEAN}. This result is also returned for the higher level expression.
  \item \texttt{expression} ('+' | '-') \texttt{expression}:Both subexpressions should return \texttt{INTEGER}. Result of the current expression is \texttt{INTEGER} aswell.
  \item \texttt{expression} ('>'|'>='|'<'|'<=') \texttt{expression}: Both sub-expressions should return \texttt{INTEGER}. Result of the current expression is \texttt{BOOLEAN}.
  \item \texttt{expression} ('==' | '!=') \texttt{expression}: The types of the sub-expressions should match. The result of this is \texttt{BOOLEAN}.
  \item \texttt{expression} ('\&\&' | '||' | '->') \texttt{expression}: Both sub-expressions should return \texttt{BOOLEAN}. Result of this is \texttt{BOOLEAN} aswell.
\end{itemize}
If any of the types do not correspond to the expected value a validation error is reported and logged. \par
In case complex types are used such as structs the additional information is retrieved from the corresponding object that is referenced. For example consider a identifier \texttt{a.b}. This would mean that the type of \texttt{a} must be a struct and that in the definition of the struct the type of the identifier \texttt{b} must be retrieved. Additionally annotations can make use of function arguments and reference them. This is solved by looking up the \texttt{SolidityFunction} object that the annotation was declared above. This makes it possible to retrieve the types of function arguments and use them within the annotation.

\section{Generation}
\label{sec:generation}
% \begin{itemize}
%     \item Explain generation of functions for annotations. Each annotation will be transformed to a function, the function takes in arguments that are also generated automatically.
%     \item Explain how functions are calling the code for checking annotations. Original Function will be transformed to a private function and renamed to 'functionName"+ \_body. New function calls this function with the extra annotations.
%     \item Implementation of generation is using a TokenStreamRewriter (with whitespace) and an abstract parse tree (only tokens that are in grammar). Tokens in both structures know the position, this way the original solidity code can be printed and extra code can be added through traversing the parse tree.
% \end{itemize}
\subsection{Design}
The next step in the tool process is the generation phase. In this phase new code will be generated and added to the original contract. Requirements are that the interface of the contract does not change. Therefore we will warp the original function in a new function which calls the original function. The functional behaviour of the contract should remain the same and the added code only performs extra checks. For each added annotation three steps have to be performed:
\begin{enumerate}
  \item Generate a function for each annotation that checks the expression. This function should have the correct number of arguments that are used within the annotation. Arguments are variables that are not reachable from the global scope and used in the expression. These are \texttt{old} variables and function variables. The only variables that are available within a function with no arguments are the global defined variables. These do not have to be given as an argument since then you have two variables defined with the same name. Other variables have to be given as an argument to the function. This includes function arguments, these are arguments that the original function has where this annotation is defined for. This is empty by construction for invariants since they do not reference a function. Additionally pre- and postconditions can use the \textbackslash old() on a variable. This means the value of the variable before the function execution, and this has also to be given as an argument to the annotation function.
  \item For each original function of the contract: Create a wrapper function with the old name which calls the original function body.
  \item Add all annotations that should be checked to the wrapper function. All variables that should be stored before the function call should be stored in memory before executing the function body. This means that all variables that are reference in an annotation with the keyword \textbackslash old() have to be stored in a variable with name 'variable + \_old'.
\end{enumerate}
To illustrate the steps consider this small example:
\begin{lstlisting}[breaklines=true, language=Solidity ]
//@ inv 'invariant_expression'

//@ post 'post_expression'
function testFunction() public{
    //...
}
\end{lstlisting}
At the end of the generation phase this will be the generated code:
\begin{lstlisting}[breaklines=true, language=Solidity ]
//@ inv 'invariant_expression'
function annotation0(){
  //check 'invariant_expression'
}

//@ post 'post_expression'
funtion annotation1('argument'){
  // check 'post_expression'
}

function testFunction() public{
  //stored variables in memory, i.e. copy all variables in 'argument'
  annotation0();
  testFunction_body();
  annotation1('argument');
  annotation0();
}

function testFunction_body() private{
    //...
}
\end{lstlisting}

\subsection{Implementation}
During the typechecking phase the object \texttt{AnnotationInformation} is created for each annotation it parses. This object contains the following information:
\begin{lstlisting}[breaklines=true, language=Java ]
public class AnnotationInformation{  
  ParserRuleContext node;
  private String name;
  private Map<SolidityVariable, Boolean> variables;
  private String type;
  private String function;

  ...
}
\end{lstlisting}
\begin{itemize}
  \item Reference to the node in the parser tree.
  \item A unique name for the annotation. This name is generated and is 'annotation' + a number.
  \item A list of arguments used in the method. The boolean indicates if it should be included as an argument for the method. As explained in the Design section. These are all arguments that cannot be reached from the global scope.
  \item Type of the annotation. Invariant, Pre or Post-condition. This indicates where it should be added to the wrapper function.
  \item Function the annotation is declared above. Null in case this is an invariant.
\end{itemize}
When parsing the tree the correct \texttt{AnnotationInformation} object is retrieved using the parse tree node. The function declaration is constructed using the name and arguments from this object. The body of this function can be constructed from the \texttt{expression} that is within the parse tree object. In most of the cases the code can directly be printed but in some cases the expression has to be altered:
\begin{itemize}
  \item The expressions \texttt{\textbackslash forall} and \texttt{\textbackslash exists} have to be replaced with a loop, that checks the expression for all the elements of the collection. 
  \item The usage of \texttt{\textbackslash old} has to be replaced with the variable that was created and initialized before the function execution. This means rewriting the variable \texttt{\textbackslash old(identifier)} to \texttt{identifier\_old}. In case of structs this is a bit more works since \texttt{\textbackslash old(a.b)} should be replaced with \texttt{a\_old.b}.
  \item Boolean operator \texttt{a->b} which can be used in annotations is not valid Solidiy code, and has to be replaced with \texttt{!a||b}
\end{itemize}
Since the annotations are type checked the generated code will always be valid. The result is always a boolean value. The actual testing of this value is done using an \texttt{assert} statement. If the value is false it means that the transaction will be reverted and all gas will be consumed. This could be changed to for example an \texttt{event}. The difference in approach is important. Assert will revert the entire transaction. A possible vulnerability that triggers the assertion will not go through as the assertion stops the execution. The vulnerability can not be exploited. In the case of changing this to an \texttt{event} the vulnerability can be exploited, but it will be registered because of the emitted event. Other behaviour can be specified here, for example calling a function that halts all the functionality of a contract except for a special function that only the admin of the contract can execute.\par
When the parser encounters a function it will check if annotations have to be added. This means searching through all \texttt{AnnotationInformation} objects and see if any of them reference the current function or are null (invariant). The original function will be transformed to a private function and renamed to 'functionName"+ \_body. The new wrapper function will call this function. The wrapper function does two other things that are important that is saving the current state of variables that are later to be used in annotations. It will only do this for variables that are referenced within \texttt{\textbackslash old(identifier)}. The second thing it does is add function calls to annotation before and after executing the original body. Annotations of type invariant are added before and after, preconditions only before and postconditions only after. \par
The actual printing of the contract code works with a \texttt{TokenStreamRewriter}\footnote{\url{https://www.antlr.org/api/Java/org/antlr/v4/runtime/TokenStreamRewriter.html}}, which is part of the ANTLR framework. The problem with printing the contract code is that the parse tree skips all whitespace. This means that the whitespace is lost in the parsing process. Including the whitespace in the parser rules would complicate the grammar because they have to be added to every rule. The ANTLR book also has an example on a similar case like this \footnote{Source code can be found here: \url{https://pragprog.com/titles/tpantlr2/source_code}. The example is in lexmagic/ShiftVarComments.java}. The idea is that the lexer gives all tokens a number in order, but the tokens are split between two channels. The parse tree only parses tokens on the first channel and ignores the others. The \texttt{TokenStreamRewriter} has the information of both channels. The token positions are still known and this way the \texttt{TokenStreamRewriter} can replace/insert text based on parser rule nodes positions. The tool uses the rewriter to insert the annotation blocks and function body in the correct places while preserving whitespace of the original contract code.

\subsection{Mappings}
The above section holds for all constructions except for \texttt{mappings}. A mapping cannot be stored in memory and is not iterable since the key set is not known. This gives problems 1) when storing the variable for \texttt{\textbackslash old()} and 2) checking a expression for all elements in a mapping. \par
This is solved by using an iterable mapping \footnote{\url{https://github.com/szerintedmi/solidity-itMapsLib}}. This works by wrapping the mapping definition within a struct. This struct contains the mapping and an array. The array stores the indexes which are used. Since the indexes are in an array these can be iterated. The key and value can be retrieved using the index. The value can also be retrieved using the key. In order for this to work extra code has to be added to the contract.
\begin{itemize}
  \item Import the library at the beginning of the contract.
  \begin{lstlisting}[breaklines=true, language=Solidity ]
  import "./itMapsLib.sol";
  \end{lstlisting}
  \item Use library function when doing operations on the struct.
  \begin{lstlisting}[breaklines=true, language=Solidity ]
  using itMaps for itMaps.itMapUintUint;
  using itMaps for itMaps.itMapAddressUint;
  using itMaps for itMaps.itMapUintAddress;
  \end{lstlisting}
  \item Replace declaration of mapping with iterable mapping.
  \begin{lstlisting}[breaklines=true, language=Solidity ]
  //mapping(address => uint256) a;
  itMaps.itMapAddressUint a; 
  \end{lstlisting}
  \item Create mapping\_old for annotation purposes. Only when the mapping is used within a \textbackslash old() expression.
  \begin{lstlisting}[breaklines=true, language=Solidity ]
  itMaps.itMapAddressUint a_old; 
  \end{lstlisting}
  \item Replace each mapping reference with \texttt{.get(...)} or \texttt{.set(...)} depending on the context.
  \begin{lstlisting}[breaklines=true, language=Solidity ]
  //uint256 b = a[0x0];
  uint256 b = a.get(0x0);
  //a[0x1] = 1;
  a.set(0x1, 1); 
  \end{lstlisting}
\end{itemize}

\section{Limitations}
\label{sec:limitations}
% mappings, contract inheritance, scoping, /result 

\section{Tool Usage}
The code of the tool is publicly available on the repository \url{https://github.com/LarsStegeman/EthereumRuntimeMonitoring}. Instructions on how to use the tool on other contracts can be seen in the README.

\hypertarget{getting-started}{%
\subsection{Getting Started}\label{getting-started}}

\hypertarget{prerequisites}{%
\subsubsection{Prerequisites}\label{prerequisites}}

\begin{itemize}
\item
  Java 1.8
\item
  Maven 3.5.3
\item
  ANTLR 4 (Maven will get this automatically when installing)
\end{itemize}

\hypertarget{installing}{%
\subsubsection{Installing}\label{installing}}

To install this tool perform the following steps

Clone this repository

\begin{verbatim}
git clone https://github.com/LarsStegeman/EthereumRuntimeMonitoring
\end{verbatim}

Build the tool using maven

\begin{verbatim}
mvn package
\end{verbatim}

Run the tool with basic example

\begin{verbatim}
mvn exec:java
\end{verbatim}

This should output the file \texttt{basicAnnotations\_generated.sol}.

\hypertarget{using-the-tool}{%
\subsection{Using the tool}\label{using-the-tool}}

\hypertarget{grammar-examples}{%
\subsubsection{Grammar examples}\label{grammar-examples}}

For example annotations see Section \ref{sec:annotationlanguage}. The grammar for the annotation
language can be found in the file
\href{https://github.com/LarsStegeman/EthereumRuntimeMonitoring/blob/master/src/main/antlr4/SolidityAnnotated.g4}{SolidityAnnotation.g4}. More
example annotations can be found in the \href{https://github.com/LarsStegeman/EthereumRuntimeMonitoring/tree/master/src/test/contracts}{test
directory}.

\hypertarget{run-the-tool-on-other-contracts}{%
\subsubsection{Run the tool on other
contracts}\label{run-the-tool-on-other-contracts}}

When the tool is build, a jar file is also generated to use the tool on
other contracts. The jar file is located in the \texttt{target}
directory. Use the tool on other contracts using the command

\begin{verbatim}
java -jar .\target\Ethereum-RuntimeVerification-1.0.jar     <my-annotated-contract.sol>
\end{verbatim}

This will generate a file \texttt{my-annotated-contract\_generated.sol}

\hypertarget{parameters}{%
\subsubsection{Parameters}\label{parameters}}

For debugging and testing the tool has two parameters which can be
switched on. They can be found in
\href{https://github.com/LarsStegeman/EthereumRuntimeMonitoring/blob/master/src/main/java/utils/Parameters.java}{Parameters.java}. The boolean
\texttt{DEBUG} enables extra print statements to be printed while
parsing. The boolean \texttt{STOPONERROR} makes it so that the tool does
not stop on the first error it encounters.

\section{Case study}
% \begin{itemize}
%   \item Take contract that has vulnerability and add annotations
%   \item Show parts of generated code that will throw an event.
%   \item Show difference in gas usage?
%   \item Show how forall annotations are handled (example contract of minimal token).
% \end{itemize}
In this section we present two case studies of smart contracts. These smart contracts will be annotated and the tool will generate the contract code with extra checks added to the code. The first example is a minimal token implementation. The second example is a contract with a vulnerability which we will show can be detected with the correct annotations.

\subsection{SimpleToken}
In this example we will use the contract SimpleToken. The contract code can be found on the Ethereum Foundation website\footnote{\url{https://www.ethereum.org/token}}. 
It models a minimum viable token. To keep the state of the contract a \texttt{mapping} is used that maps \texttt{address} to \texttt{uint}. This mapping is kept in the contracts' internal storage and is stored on the blockchain. It indicates which amount each address holds of this token and changes each time the \texttt{transfer} function is called. The \texttt{transfer} function requires two parameters an address (\texttt{\_to})  and an uint(\texttt{\_value}) which specifies the amount to be sent. The from address is determined from the global variable \texttt{msg} which is present in each transaction. The require statements in the transfer function will check if the sender has enough balance to sent the amount specified in \texttt{\_value}, and test for overflows in the balance of the receiver. If one of the two fails an exception will be thrown and the changes this transaction made will be reverted.\par
When the contract is created the constructor will be called. In this constructor the initialSupply is given as a parameter. All the initial supply is given to the contract creator (\texttt{msg.sender}). The totalSupply value is assigned and cannot be changed after initialization.\par
Note that this contract is not ERC20 compliant\footnote{\url{https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md}}. ERC20 is the interface that most tokens use to implement the desired functionality. This interface is defined in order for all wallets and exchanges to be able to handle different tokens. The main difference is that this contract does not have an \texttt{approve} mapping which lets users approve a certain transfer of tokens. Also this SimpleToken does not allow \texttt{minting} or \texttt{burning} of tokens, in other words the total supply is fixed. Below we can see the Solidity source code of the contract SimpleToken.

\lstinputlisting[language=Solidity, breaklines= true, tabsize = 2, literate={\ \ }{{\ }}1]{examples/SimpleToken.sol}

\subsubsection{Annotation}
The above section describes the implementation of the token contract. However there is also a specification given in words as to what the contract should do. A few properties of this specification can be declared explicitly using pre and post-conditions or invariants. These properties are important to the functionality of the contract. 
The first property is that when a transfer function is executed the balance of the \texttt{\_to} address is incremented with the \texttt{\_value}. And the balance of the sender is decreased with the same value. The rest of the balances remains the same. This property should be checked after the execution of the \texttt{transfer} function. Using the correct syntax the annotation will look:
\begin{lstlisting}[basicstyle=\ttfamily, breaklines=true ]
//@ post 
 (balanceOf[_to] == (\old(balanceOf[_to]) + _value) 
 && balanceOf[msg.sender] == (\old(balanceOf[msg.sender]) - _value) 
 && \forall(x in balanceOf: (x != _to && x != msg.sender) -> balanceOf[x] == \old(balanceOf[x]))) 
 || msg.sender == _to 
\end{lstlisting}
Going over it line by line:
\begin{enumerate}
  \item Indicate that this is an annotation and not a comment. And this is of type post condition.
  \item Balance of \texttt{\_to} gets incremented by \texttt{\_value}
  \item Balance of \texttt{msg.sender} gets decremented by \texttt{\_value}
  \item Rest of the balances does not change.
  \item This is makes the annotation also valid for the special case where \texttt{\_to} is equal to \texttt{msg.sender}. In this case all of the balances do not change.
\end{enumerate}

\subsubsection{Generated Code}
When the tool gets executed with the above contract as input including the annotation, the tool will parse the annotation and output generated solidity code with extra checks. 
The complete generated code can be seen below.
\lstinputlisting[language=Solidity, breaklines= true, tabsize = 2, literate={\ \ }{{\ }}1]{examples/SimpleToken_generated.sol}

Note that the functionality of this contract is exactly the same as the previous code but with extra checks. This means that this approach is only feasible for development purposes. Since the gas cost of executing the previous contract is much lower then that of the runtime monitored contract. Also the more addresses that get added to the iterable map the more gas the transaction will consume.


\subsection{Vulnerable Contract}
The next example is a simple contract with a vulnerability. The vulnerability will not be easily visible when reading the contract, but with extra annotations added this is visible. This contract is not actually in use but is based on a CryptoRoulette contract \footnote{https://github.com/misterch0c/Solidlity-Vulnerable/blob/master/honeypots/CryptoRoulette.sol}. Most of the contract code is omitted for this example. The idea is that the contract keeps a list of messages, for each message the sender and the message are saved. Only the address \texttt{admin} has extra privileges to possibly delete messages or delete the contract (these functions are not in the snippet).
\lstinputlisting[language=Solidity, breaklines= true, tabsize = 2, literate={\ \ }{{\ }}1]{examples/VulnerableContract.sol}

\subsubsection{Annotation}
The annotation that is added to the function \texttt{logMessage} checks the basic behaviour of the function. The address \texttt{admin} should not be changed, and the number of messages should be increased by one. This should be checked after the function is executed.
\begin{lstlisting}[basicstyle=\ttfamily, breaklines=true ]
//@ post admin == \old(admin) && (nrOfMessages == (\old(nrOfMessages) + 1))
\end{lstlisting}
\subsubsection{Generated Code}
The code that is generated stores the original variables in memory before calling the function body. After the function is executed the old variables will be compared to the current state variables. Every call to the function \texttt{logMessage} will report an error since each time the state variables \texttt{admin} and \texttt{nrOfMessages} are changed. These are changed because the struct \texttt{message} within the function body defaults to \texttt{storage}. 
\lstinputlisting[language=Solidity, breaklines= true, tabsize = 2, literate={\ \ }{{\ }}1]{examples/VulnerableContract_generated.sol}

\section{Future work}
\begin{itemize}
  \item The tool cannot handle contract inheritance.
  \item The tool does not have a mechanism for exposing the parse tree for other programs after validation.
\end{itemize}

\section{Related Work}
\begin{itemize}
  \item ContractLarva: runtime monitoring based on defined states and transitions.
  \item 
\end{itemize}

\bibliographystyle{IEEEtran}
\bibliography{IEEEfull,references}
\end{document}