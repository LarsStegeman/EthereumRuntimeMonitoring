\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{url}
\usepackage{listings}
\usepackage{enumitem}

%% Solidity highlighting for listings
\input{solidity-highlighting.tex}
\lstset{escapeinside={<@}{@>}}


\title{Runtime Verification of Smart Contracts \\
\large On the Ethereum network \\}

\author{Lars Stegeman [s1346466]\\ l.stegeman@student.utwente.nl}

\begin{document}

\maketitle

\tableofcontents



\section{Abstract}

\section{Introduction}

\section{Solidity}

\section{Tool Overview}

\section{Annotation Language}
The first step towards implementing the tool is to define an annotation syntax, and formally write this down using a grammar.

\subsection{ANTLR}
\subsection{Grammar definition}
There already exists a grammar for the complete Solidity language. This grammar is written down using the language that is used by ANTLR tool. ANTLR is a parser generator which helps automate the building of a compiler. ANTLR has the capabilities to extend certain grammars. This is done by inheritance over the original grammar. This principle is explained in detail here (find ref). We will use this principle to extend the grammar of Solidity to recognize the special annotations that will later be used in the tool. \\
The annotations have certain requirements that can be summarized the following way. Later each requirement is discussed in detail.
\begin{itemize}
    \item Annotations can be specified at the top level.
    \item Annotations should be able to reference all variables used in the contract.
    \item Basic math operations can be used within annotations.
    \item Annotations can not have side effects.
    \item The type should be boolean at the highest level (that way they can be verified).
    \item There are two types of annotations invariants and pre- or postconditions to a function.
    \item Global variables (\texttt{msg} and \texttt{address}) can be used in annotations.
\end{itemize}

The annotation syntax is heavily inspired from the JML annotation syntax. But has a lot less built in keywords since the setting is easier and the tool is less complex. The original grammar is extended in such a way that annotations can only be defined on the top level. The relevant parts of the original Solidity grammar can be seen in the snippet below. This does not include the full grammar specification but only the parts that are relevant for the annotation syntax.

\begin{lstlisting}[basicstyle=\ttfamily]
grammar Solidity;

sourceUnit
  : (pragmaDirective | importDirective | contractDefinition)* EOF ;

contractDefinition
  : ( 'contract' | 'interface' | 'library' ) identifier
    ( 'is' inheritanceSpecifier (',' inheritanceSpecifier )* )?
    '{' contractPart* '}' ;

contractPart
    : stateVariableDeclaration
    | usingForDeclaration
    | structDefinition
    | constructorDefinition
    | modifierDefinition
    | functionDefinition
    | eventDefinition
    | enumDefinition ;
\end{lstlisting}
In the original grammar the definition of \texttt{contractPart} is what defines the declaration of variables and the definitions for structs and functions. This is where the extra annotations have to be added to the grammar. The snippet below shows the basic definition of an annotation. This is not the complete grammar some of the tokens are omitted from this snippet, since they are not required to understand the grammar definition.
\begin{lstlisting}[basicstyle=\ttfamily]
grammar SolidityAnnotated;
import Solidity;

contractPart
  : stateVariableDeclaration
  | usingForDeclaration
  | structDefinition
  | constructorDefinition
  | modifierDefinition
  | functionDefinition
  | eventDefinition
  | enumDefinition 
  <@\textcolor{red}{  | annotationDefinition ;}@>

annotationDefinition
  : AnnotationStart AnnotationKind annotationExpression ;

annotationExpression
  : '(' annotationExpression ')'
  | annotationExpression compareOp annotationExpression
  | annotationExpression booleanOp annotationExpression
  | annotationExpression integerOpBoolean annotationExpression
  | annotationExpression integerOpInteger annotationExpression
  | '!'annotationExpression
  | ('\\forall' | '\\exists') '(' identifier elementaryTypeName ':' annotationExpression? ':' annotationExpression')'
  | primaryAnnotationExpression ;

primaryAnnotationExpression
  : primaryExpression 
  | primaryAnnotationExpression '.' identifier
  | primaryAnnotationExpression '[' primaryExpression ']'
  | '\\old' '(' primaryAnnotationExpression ')' ;

AnnotationStart
  : '//@' ;

AnnotationKind
  : 'inv'| 'pre'| 'post' ;

LINE_COMMENT 
  : '//' ~[@] ~[\r\n]* -> channel(HIDDEN) ;
\end{lstlisting}
An AnnotationDefinition is composed of multiple components. It has a \texttt{AnnotationStart}, \texttt{AnnotationKind} and \texttt{annotationExpression} component. The \texttt{AnnotationStart} token is used to signal that an annotation definition is coming next. This is defined as '//@' making it a line comment to other solidity compilers. This makes annotated solidity code still compilable by normal compilers. For the grammar to accept this notation the \texttt{LINE\_COMMENT} token has to be adjusted to not accept '@' as a second character. Otherwise all annotation comments would be recognized as a \texttt{LINE\_COMMENT} making it unusable. \\
There are two types of annotations they are defined by the token \texttt{AnnotationKind}. They can either be a invariant or a pre- or post-condition of a function. \\
Each annotation has an expression which has to be evaluated called \texttt{annotationExpression}. The expression parser rules are separated between \texttt{annotationExpression} and \texttt{primaryAnnotationExpression}. This is needed to keep the hierarchy in parsing and prevent using primary definitions with complex expressions. For example using the keyword '\textbackslash old' before parenthesis.\\
The annotation expressions use a different parser rules than the expression rules that are used within the original Solidity grammar. The \texttt{annotationExpression} does not allow syntax like \texttt{expression + '++'} and to distinguish these a new parser rule was introduced for annotations only.

\section{Validation}
\subsection{Design}
Annotations have to be validated on certain aspects for them to be correct and usable. These aspects have to be verified first for the annotations to be useful in the next generation phase. The parser ensures annotations are syntactically correct however there are more properties that have to be checked.
In short the validation step within the program has to do the following things:
\begin{itemize}
    \item Collect all variables within the contract.
    \item Typecheck annotations.
\end{itemize}

The validation phase will consist of two programs that walk the complete parse tree. The first walk will collect all the variables and defined structures and store these in an information object. The second walk will type check each annotation individually. During this type checking the type of each identifier is looked up using the collected information from the first walk. 
\subsection{Implementation}


\section{Generation}
\begin{itemize}
    \item TODO
\end{itemize}


\end{document}