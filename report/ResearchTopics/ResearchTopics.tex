\documentclass[a4paper]{article}

%% Language and font encodings
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}

%% Sets page size and margins
\usepackage[a4paper,top=3cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

%% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{url}
\usepackage{listings}

%% Solidity highlighting for listings
\input{solidity-highlighting.tex}


\title{Runtime Monitoring of Smart Contracts \\
\large On the Ethereum network [DRAFT] \\}

\author{Lars Stegeman [s1346466]\\ l.stegeman@student.utwente.nl}

\begin{document}

\maketitle

\tableofcontents


\section{Introduction}
Each day new smart contracts are deployed to the Ethereum network. Some of these smart contracts control a large sum of Ether. Since this Ether has real world value and the source code for smart contracts is in the open many people are finding vulnerabilities within contracts. Several high profile security bugs were found and exploited. This sparked the interest in static analysis tools and formal verification of smart contracts. Static analysis tools can be executed on many contracts and report valuable information on common mistakes. However unknown vulnerable patterns will not be detected since they have to be explicitly programmed to be able to analyse the specific pattern. Other tools which use formal verification need a specification to be able to guarantee a contract behave the correct way. These specifications are usually written in another language or defined at the EVM level. This makes it hard to understand what properties are proven and what that means for the contract. Smart contract developers will have a hard time understanding all these separate tools and their diverse syntax. This paper will describe a concept tool which makes it possible to write specifications at the same level of Solidity code. These specifications will then be parsed and can be used for a number of different analyses. The benefits of this approach are:
\begin{itemize}
    \item Explicitly writing a specification helps understanding the problem. The code usually describes how a contract should behave and do calculations. While the specification should describe what the contract does and what properties should be satisfied.
    \item Runtime exceptional state. While the contract is active on the main Ethereum network properties can be checked at runtime. If a certain property fails due to an untested case, the program can go into an exceptional state. In this state, functions can be deactivated or the contract can be completely cleared. 
    \item It helps with bug bounty programs. When new contracts are developed they usually first launch a bug bounty program. Vulnerabilities that discovered by users can be rewarded by the creators of the contracts before it goes live on the main network. In most of these programs the specification of what the contract should do is not given. This makes it difficult do decide what is intended behaviour and what counts as a found vulnerability. With runtime verification one could specify properties that the contract should satisfy. If one of these properties fail because of a vulnerability found by the community, it is guaranteed not to be intended. This makes these bug bounty programs more useful for both the creator and the participants. 
    \item  The output of the tool is Solidity code which means that it can serve as input to other formal verification tools. For example the KEVM framework, which formally verifies smart contracts at the EVM bytecode level. 
\end{itemize}
The rest of this paper will be structured as follows. First the background information is given about the Ethereum blockchain and underlying principles. Then smart contract are introduced and explained at a high level overview. Next Solidity, the most used contract programming language, is discussed. Section \ref{sec:example} will have an example for a possible use of the concept tool. Then runtime monitoring is introduced and other related work is explained. The last section contains the research questions and a planning for the development of the tool. 



\section{Background}
This section will discuss the background information that will be built upon further in the document. First we will briefly discuss the important parts of the Ethereum Blockchain. Then we will discuss the Smart Contracts in more detail.
\subsection{The blockchain}
The Ethereum platform is built upon a distributed public ledger. On this ledger the cryptocurrency ether is stored. It is opposed to Bitcoin, based on an account based system and not unspent transaction output. There are two types of accounts, one is a default account in which a user controls the spending of funds through its private keys. These accounts are called "Externally owned Accounts". An account can be referenced by its address which is a hashed version of the public key. Each address has a balance and a nonce. The nonce is incremented each time the balance is updated with a transaction. The other option is a "Contract Account", which means that it is managed by code only. A contract account has more data stored on the blockchain. These include storage hash and a code field. The code is set when the contract is constructed and initialized on the blockchain, and after that can never be changed. Each contract has a persistent storage which is also maintained on the blockchain. Contract accounts only execute code when they are called from other contracts. Transactions are the only entity that make changes to the storage. At an higher level overview we could see the Ethereum network as a large state machine in which changes to the state are controlled by transactions. Transactions are grouped in blocks and these blocks are distributed over the network and validated by each node. \\
This is also described more formally in the Ethereum Yellow Paper \cite{wood2014ethereum}. The Yellow Paper states that there are three separate storages in each context.
\begin{itemize}
    \item World state ($\sigma$): A mapping of Ethereum addresses to the accounts. Which is a balance and nonce for an account, and storage and code for contracts.
    \item  Machine state ($\mu$): State of the currently executing code from a transaction. This includes program counter, memory and virtual machine.
    \item Execution Environment (I): Variables related to this transaction. For example caller address, amount of ether send and call data.
\end{itemize}
Transactions can only be initiated from accounts. This means that the blockchain is global state computer which changes each time a transaction is executed. Transactions can be seen as function calls with additional information. This information includes the transaction sender, gas price and amount of ether.\\
Blocks serve the purpose to group transactions and give them order. Since this ordering is very important to the outcome of the transaction. This should be deterministic and all nodes should agree on the global state. This securing of blocks is done using a proof of work mechanism that is used by most cryptocurrencies. However each miner also has to validate each transaction by executing the corresponding EVM code and adjusting the global state. This is also done by each individual node to validate the block which includes all the transactions.

\subsection{Smart Contracts}
Smart contracts are usually mentioned together with Ethereum. Other terms for smart contracts are "autonomous agent" or "executable code on the blockchain". It has many application domains according to the Ethereum White Paper \cite{buterin2013ethereum}. This includes token systems, decentralized autonomous organizations (DAO), financial derivatives, identity/reputation systems and decentralized file storage. The idea is that these domains are perfect for the blockchain since they take away the untrusted third party. Smart contracts can only operate on data within the blockchain, this means that all information has to be included in the transactions that are send from "externally owned accounts". However in this paper we will look at the functional capabilities of smart contracts on the Ethereum network. \\ 
Smart Contracts on the Ethereum network consist of two parts. Each contract has a set of functions and a storage. The contract set of functions is defined by the contract code that is deployed with the contract creation. This contract code is EVM bytecode and is usually compiled from a higher level programming language. When the contract is created the storage is initially empty. Only the contract code can make changes and add data to the persistent storage, within this storage the state of the contract is maintained. As explained before each transaction also has a state. This is called \texttt{memory}, and is initially empty. It can also be used to store data and is much cheaper in terms of gas cost. But this data is not persistent through transactions, it is only persistent within the transaction. There are also so called "logs", this storage can only be used to store data and not retrieve. This storage is usually used to provide data for the external world because it can be searched efficiently.\\
Functions are only executed when they are called by external contracts. For example if a fund is to be released after a certain amount of time (block number higher then a certain amount). These funds will not be automatically transferred once the time threshold is reached, they will only be released when the function is called again.\\

\subsection{Smart Contract bugs}
Many smart contracts are deployed to the Ethereum main network every day. When a contract is created on the blockchain the contract code is stored on the blockchain forever. This cannot be changed afterwards. Because of this limitation bugs within smart contracts can be very costly. In the past many vulnerabilities have been detected causing a loss of several million Ether. This paper will not enumerate all of them since many other articles do a good job of summarizing all the found vulnerabilities. For a complete overview see \cite{dika2017ethereum} section 3, where each attack with its corresponding vulnerability is explained in detail.

\section{Solidity}
\label{sec:solidity}
The most used language to develop contracts on Ethereum is Solidity \cite{solidityreadthedocs}. Solidity comes with a compiler that compiles Solidity code into EVM bytecode. This bytecode is what is executed and put on the blockchain. Solidity has features like control flow, types and different storage constructions. Additionally it has some global variables that apply only to the blockchain setting. In this section we will further introduce the language in detail.
\subsection{Syntax}
The syntax that is used by Solidity is heavily inspired by Javascript. Solidity is in contrast to Javascript strongly typed. It offers the common types in normal programming languages like; booleans, integers, strings, fixed point numbers. Since each contract is executed on the blockchain storage is extremely costly in terms of gas cost. This is why many different sizes for integers exist: \texttt{uint8}, \texttt{int8}, \texttt{uint16}, until \texttt{uint256} and \texttt{int256}. \\
Solidity offers a number of different options for more complex types. These complex types have an extra annotation that defines their storage location. This can either be \texttt{storage} or \texttt{memory}. 
\begin{itemize}
    \item Structs are a form to create new types in Solidity. Structs can contain any type including mappings except itself.  
    \item Arrays can be defined in memory or storage. Storage arrays can hold arbitrary types, memory arrays can not contain mappings. Storage arrays can be dynamically increased in size, however memory arrays are always fixed length.  
    \item Mappings can only be defined in storage. They map a key of a certain type to a value of another type. They can be compared to hash tables in normal programming languages. However the key set of a mapping is not stored, this makes mappings not iterable. 
\end{itemize}

\subsection{Structure}
In Solidity contracts are treated like objects in Object Oriented Programming languages. Contracts can contain state variables and functions and inheritance is supported between multiple contracts. A contract can have a constructor which will be called upon creation of the contract on the blockchain. 
\subsection{Blockchain specific variables}




\section{Example}
\label{sec:example}
In this section a small example will be introduced. This example helps understand the problem this research tries to solve. The tool that will parse specification is not implemented yet, that is why in this example the specification is translated by hand. First we will introduce the contract and what is it supposed to do. Next we will add the specifications to the contract that we wish to check for during runtime. After that we will look at the code of the runtime monitored contract, which is made by translating the specified properties to Solidity code and adding it to the existing contract. Lastly we will discuss what this means for the contract in terms of gas execution and additional changes that had to be made to the contract.

\subsection{Simple Token}
In this example we will use the contract SimpleToken. The contract code can be found on the Ethereum Foundation website \footnote{\url{https://www.ethereum.org/token}}. 
It models a minimum viable token, to keep the state of the contract a \texttt{mapping} is used that maps \texttt{address} to \texttt{uint}. This mapping is kept in the contracts internal storage and is stored on the blockchain. It indicates which addresses holds how much of this contracts token and changes each time the \texttt{transfer} function is called. The \texttt{transfer} function requires two parameters an address (\texttt{\_to})  and an uint(\texttt{\_value}) which specifies the amount to be sent. The from address is determined from the global variable \texttt{msg} which is present in each transaction. When the contract is created the constructor will be called. In this constructor the initialSupply is given as a parameter. All the initial supply is given to the contract creator (\texttt{msg.sender}). The totalSupply value is assigned and cannot be changed after initialization.\\
Note that this contract is not ERC20 compliant. ERC20 is the interface that most tokens use to implement the desired functionality. This interface is defined in order for all wallets and exchanges to be able to handle different tokens \footnote{\url{https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md}}. The main difference is that this contract does not have an \texttt{approve} mapping which lets users approve a certain transfer of tokens. Also this SimpleToken does not allow \texttt{minting} or \texttt{burning} of tokens, in other words the total supply is fixed. Below we can see the Solidity source code of the contract SimpleToken.

\lstinputlisting[language=Solidity]{examples/SimpleToken.sol}

\subsection{Specification}
The above section describes the implementation of the token contract. However there is also a specification given in words as to what the contract should do. A few properties of this specification can be declared explicitly using pre and postconditions or invariants. These properties are important to the functionality of the contract. Properties could be translated to corresponding Solidity code and added to the contract. This code is executed within each transaction and thus the properties are checked and validated at runtime. \\
The first property is that the value of \texttt{totalSupply} is always equal to the sum of all the individual balances in the mapping \texttt{balanceOf}. Another property is that when a transfer function is executed the balance of the \texttt{\_to} address is incremented with the \texttt{\_value}. And the balance of the sender is decreased with the same value. The first property can be seen as an invariant of the contract and should hold before and after execution of a function. The second property should be checked after the execution of the transfer function and can be represented as a postcondition on that function. The exact syntax on how to declare these properties is not defined yet. This example will use syntax that is close to the syntax that is used by JML.

\lstinputlisting[language=Solidity]{examples/SimpleToken.spec.sol}
 
\subsection{Implementation of RuntimeMonitoredSimpleToken}
The specification together with the solidity code should be compiled to a new smart contract. The compiled smart contract will have the same behaviour but with extra assertions added to the code. The tool should be able to parse specifications and add the correct code to the corresponding functions. For this example the code will be made by hand because the tool still needs to be developed. The contract solidity code for the Runtime-Monitored SimpleToken can be seen in the snippet below.\\
For this example if an assertion in the specification is false, the call will return an error. Later more complex behaviour can be added when this situation occurs. The way the contract works from the outside should not change, because several front-end implementations could depend on it. This means that the added behaviour should be inside the functions that are in the original contract. To accomplish this the transfer function body is moved to a separate private function \texttt{transfer\_body()}. The original transfer function will do several things. First it stores the current state in the \texttt{memory} storage of the contract. This is needed because specifications can use the \texttt{\textbackslash old} keyword to reference to variables before the function execution. Next it checks the invariant and possible preconditions. After that the function body is executed. Lastly the postcondition and invariant are checked, the state before execution is passed as a parameter to the functions. 

\lstinputlisting[language=Solidity]{examples/RuntimeMonitoredSimpleToken.sol}

\subsection{Discussion}
There are a few choices that had be made during the implementation of the runtime contract. \\
The first observation is that a \texttt{mapping} variable is not iterable. This means that properties that use quantifiers and reference mappings cannot be tested at runtime. Mappings in Solidity do not store a keyset and just store the information at the corresponding hash of the key.  This limitation can be avoided if we store the used keyset in an additional array. This array must be kept in the storage since it must be persistent between transactions. The SimpleToken contract has only one mapping and the storage array \texttt{addressesInUse} keeps track of the keys. A more general approach would be to define a new storage construction called IterableMapping \footnote{\url{https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol}}. \\
Another limitation is that mappings cannot be declared in \texttt{memory}. Thus to store the variable \texttt{\textbackslash old(someMapping\{ key => value\}} there is  need for either a additional mapping in \texttt{storage} or the mapping can be represented by a struct array (which can be stored in \texttt{memory}). The last approach is used in the example, but additional analysis is needed to determine which method is the most gas efficient. Gas cost is significantly higher for \texttt{storage} in comparison to \texttt{memory}, but additional actions are required to have the information converted to a struct variable.\\
Lastly because of additional checks the gas cost for each function is not constant anymore. This effect is worse compared to the increase of gas cost in normal contracts. For example if the SimpleToken contract had 1000 addresses in use the cost of each function call would not increase in the original contract. But in the runtime-monitored contract the gas costs would increase since the array \texttt{addressesInUse} has length 1000 which causes extra iterations for validation. The additional gas cost are not analysed for this SimpleToken contract, but in the final tool tests with multiple transactions should be analysed for their gas cost.


\section{Runtime monitoring} 


\section{Property specification}


\section{Related Work}
There is a lot of work related to this topic. There are papers discussing the verification of smart contracts. They can be further categorized as static analysis or formal verification. Additionally other contract languages have been proposed to help writing secure smart contracts. The last subsection discusses some other related work.

\subsection{Smart Contract Verification}
Due to the recent exploits that were found on the Ethereum blockchain this research area has seen a lot of attention. Especially in the field of formal verification. There are many proposals of verification tools that will help to write secure smart contracts. The security of smart contracts is important because if the bytecode of a contract is committed to the blockchain it cannot be changed afterwards. This means that testing and verification of the code before committing it to the network is important. The efforts can be categorized in two groups; static analysis and formal verification. The first class are tools that analyse the EVM code or a higher level code and check for patterns. Patterns that are known to be vulnerable get reported. The code is not actually executed, only symbolically. The second group is formal verification. These tools work by giving a specification for a given program. The tool then proofs that the program is correct for all possible inputs with respect to the given specification. Some tools fully automate this process, some work with a proof assistant. Note that the Solidity code is usually translated to EVM or some intermediate language in which the proofs can be more easily automated.
\subsubsection{Static Analysis Tools}
There are many tools that are defined in this area. Most of the tools have the same functionality. You can analyse contracts, either by Solidity code or EVM bytecode. These contracts can be analysed locally or from an online provider (Ethereum mainnet or one of the test nets). Examples of such tools are Mythril \cite{mythrilrepo}, Securify \cite{securifywebsite} and Oyente \cite{luu2016making}. The Oyente tool also offers the possibility to analyse all the contracts on the whole blockchain. Their tool is not only available on Github but also has a paper which describes the choices made fo the analysis tool. The tools under this category do not test for errors in business logic. For example if a function returns too much ether on a specific input, this will not be detected by static analysis tools. 
\subsubsection{Formal Verification Tools}
To verify a contract a specification has to be written. Specification gives meaning to what the contract should do. However because Solidity is not fit for this most tools are defined at the EVM bytecode level, or introduce an intermediate contract language. These programs are then proven correct considering all possible inputs with respect to the given specification. KEVM \cite{hildenbrandt2017kevm}, a formalization of the EVM in F* \cite{grishchenko2018semantic} and eth-isabelle \cite{hirai2017defining} are very similar. All three tools are able to execute a large set of the official ethereum test suite and are able to proof specifications correct for certain contracts. Other approaches use an intermediate language over which properties can be proven correct. Lolisa \cite{yang2018lolisa} and Scilla \cite{sergey2018scilla} fall under this category. 

\subsection{Smart Contract Languages}
Smart contracts are usually written in a high level language that compiles to EVM (Ethereum Virtual Machine) bytecode. Currently the best known and most used language is Solidity (as described in detail in section \ref{sec:solidity}). But there are other options available that also compile to EVM bytecode. They differ in their syntax and influences by other languages.  
\subsubsection{Bamboo}
Bamboo is a morphing smart contract language. State transitions the core part of the language design. This makes the state transitions in smart contracts explicit. This way it avoids re-entrancy by default. Instead of having a global state of the contract, contracts morph into a new contract by calling functions. This way there should be less surprises in the execution of smart contracts. The project is located in a repository located at \url{https://github.com/pirapira/bamboo}. As an example the smart contract for a crowd funding is used. The crowd funding usually has several stages in which different things can happen. In Solidity these stages are usually modeled using boolean variables and enforced using \texttt{modifiers}. With this approach it is hard to keep track which functions are enabled at which state. In Bamboo this is not the case since functions are declared within an state and functions modify the signature of the smart contract. 
\subsubsection{Vyper}
Vyper is a new and experimental smart contract programming language. It is maintained by the Ethereum Foundation at \url{https://github.com/ethereum/vyper}. The idea is to limit certain functions and aspects that are possible in Solidity to make writing smart contracts less error prone. It also tries to make smart contracts more human readable to make it simpler to see what will happen when a function is called. For example \texttt{modifiers}, inline assembly and class inheritance is not allowed in Vyper as opposed to Solidity. 

\subsection{Other related work}
A number of other proposals have been published which try to make smart contracts more secure. They do not belong to a certain category but are related to the current work. Some projects only have source code available and do not have documentation or a paper.
\subsubsection{ContractLARVA}
ContractLARVA can be found on github at \url{https://github.com/gordonpace/contractLarva}. Following the instructions on the README you can write a specification and a contract in Solidity. The compiler will combine these two and output a new Solidity contract with the runtime verification checks in place. Properties have to be specified using \textit{dynamic event automata} (DEA) \cite{CGG08FMICS}. The tool is based on a similar tool called LARVA for Java. 

\subsubsection{Ethereuem-runtime-verification}
This project is located at \url{https://github.com/shaunazzopardi/ethereuem-runtime-verification}. No documentation is available for this project. It mentions the LARVA project in the description in that it differs from LARVA because this runtime-verification tool can dynamically add properties to an already deployed smart contract.

\subsubsection{The Hydra Project}
The Hydra Framework is a project for smart contracts on the Ethereum network. It tries to make smart contracts more secure by making multiple implementations of the same contract. They call this \textit{N-of-N-version programming}. The different implementations are controlled by a meta contract which forwards the incoming calls to all the implementations. If the implementations do not agree on a single answer, the meta contract will be able to react on this. When such a vulnerability is found a bounty is given to the person who exploited the vulnerability. They call this principle \textit{the exploit gap}, this means that a hacker should claim the bounty instead of exploiting the vulnerability. More information can be found in their paper \cite{breidenbachenter}. 

\subsubsection{FSolidM}
FSolidM \cite{mavridou2018tool} is a fully functional tool which helps developing secure smart contracts. It provides a GUI to specify contracts using finite state machines (FSM). These FSMs are then translated to secure solidity contract code. This tool helps creating secure smart contracts since the semantics of the FSM is well defined. The tool comes with a code generator for generating Solidity code, and also the possibility to define plugins. These plugins can be used to define certain patterns that implement common design patterns or include security constraints. 
\subsubsection{Quantitative Analysis of Smart Contracts}
Chatterjee et al. \cite{chatterjee2018quantitative} analyse the utility (expected payout) for smart contracts. It does so by using game theory and incentives to analyse a stateful game. It uses a simplified contract language and translates these contracts to state-based games. These games can then be analysed by the tool for their expected payout. The functions in the games are assumed to be executed at distinct timeslots. This is however not the case for Ethereum since one can always write a specific contract to call all functions within the same transaction. Also calls to other contracts are not considered while this is where most of the complexity and vulnerabilities are discovered in real world contracts.







\section{Planning}



\bibliographystyle{IEEEtran}
\bibliography{IEEEfull,references}
\end{document}